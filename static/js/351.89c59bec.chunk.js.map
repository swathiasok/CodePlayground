{"version":3,"file":"static/js/351.89c59bec.chunk.js","mappings":"qKA2BO,SAASA,EAAwBC,GACpC,MAAMC,EAAO,IAAIC,YA2BrB,SAAqCF,GACjC,IAAIG,EAAS,EAIb,GAHAA,GAAW,EAGiB,SAAxBH,EAAeI,KACfD,GAAW,EACLH,EAAeK,KAAKC,WAEzB,CACDH,GAAW,EAEXA,GAAU,EAGNH,EAAeO,OAAOD,OAC1B,IAAK,MAAME,KAASR,EAAeO,OAC3BC,EAAMH,OACNF,GAAUK,EAAMH,KAAKC,OAGjC,CACA,OAAOH,CACX,CAlDiCM,CAA4BT,IACzD,IAAIU,EAAS,EAEb,GADAT,EAAKS,KAAYV,EAAeW,GACJ,SAAxBX,EAAeI,KACfH,EAAKS,KAAY,EACjBT,EAAKS,KAAYV,EAAeK,KAAKC,OACrCL,EAAKW,IAAIZ,EAAeK,KAAMK,GAC9BA,GAAUV,EAAeK,KAAKC,WAE7B,CACDL,EAAKS,KAAY,EACjBT,EAAKS,KAAYV,EAAeO,OAAOD,OACvC,IAAK,MAAME,KAASR,EAAeO,OAC/BN,EAAKS,KAAYF,EAAMK,MACvBZ,EAAKS,KAAYF,EAAMM,YACnBN,EAAMH,MACNJ,EAAKS,KAAYF,EAAMH,KAAKC,OAC5BL,EAAKW,IAAIJ,EAAMH,KAAMK,GACrBA,GAAUF,EAAMH,KAAKC,QAGrBL,EAAKS,KAAY,CAG7B,CACA,OAlCJ,SAA8BK,GAC1B,MAAMC,EAAW,IAAIC,WAAWF,EAAIG,OAAQH,EAAII,WAAyB,EAAbJ,EAAIT,QAKhE,OAJKc,EAAAA,MAfT,SAA2BL,GACvB,IAAK,IAAIM,EAAI,EAAGC,EAAMP,EAAIT,OAAQe,EAAIC,EAAKD,GAAK,EAAG,CAE/C,MAAME,EAAKR,EAAIM,EAAI,GACbG,EAAKT,EAAIM,EAAI,GACbI,EAAKV,EAAIM,EAAI,GACbK,EAAKX,EAAIM,EAAI,GACnBN,EAAIM,EAAI,GAAKK,EACbX,EAAIM,EAAI,GAAKI,EACbV,EAAIM,EAAI,GAAKG,EACbT,EAAIM,EAAI,GAAKE,CACjB,CACJ,CAKQI,CAAkBX,GAEfY,EAAAA,GAASC,KAAKb,EACzB,CA2BWc,CAAqB7B,EAChC,C","sources":["../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n"],"names":["encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","result","type","data","length","deltas","delta","encodeSemanticTokensDtoSize","offset","id","set","start","deleteCount","arr","uint8Arr","Uint8Array","buffer","byteOffset","platform","i","len","b0","b1","b2","b3","reverseEndianness","VSBuffer","wrap","toLittleEndianBuffer"],"sourceRoot":""}